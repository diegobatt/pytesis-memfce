A continuación se disponen los resultados obtenidos de los intervalos de confianza para los conjuntos de datos introducidos en la @sec-methods-data-synth. Se observa en primera instancia un ejemplo de resultado de diagrama de persistencia junto con su intervalo de confianza para cada método desarrollado en la @sec-methods-intervals y posteriormente se procede a repetir el experimento una cantidad $M$ de veces para analizar la potencia, estimada como la tasa de aciertos a la hora de rechazar la hipótesis de no existencia de agujeros en el conjunto de datos, para cada uno de los métodos utilizados sobre los distintos espacios topológicos sintéticos presentados

```{python}
import warnings
warnings.simplefilter(action="ignore", category=FutureWarning)
warnings.simplefilter(action="ignore", category=UserWarning)

from pytesis.datasets import (
    arc,
    eyeglasses,
    filled_circle,
    add_noise,
    add_outliers
)
from pytesis.results import run_all_intervals, run_all
from pytesis.utils import compose

from functools import partial

import random

random.seed(2)

# Multiprocessing stuff
if __name__ == '__main__':
    __spec__ = "multiprocessing-stuff"
```


```{python}
# Common
n = 500
sd = 0.075
iqr_factor = 0.3
outliers_frac = 0.02
h = 0.3
B_intervals = 200
B_power = 30
robust_quantile = 0.97
# Eyeglasses
n_eyeglasses = 750
bridge_height = 0.5
sd_eyeglasses = 0.04
h_eyeglasses = 0.20
# Filled circle
n_filled = 750
r_power = 2.6
max_r = 1.5
h_filled = 0.3

# Circle
circle_factory = partial(arc, n=n)
circle_noise_factory = compose(partial(add_noise, sd=sd), partial(arc, n=n))
circle_outliers_factory = compose(
    partial(add_outliers, frac=outliers_frac, iqr_factor=iqr_factor),
    partial(arc, n=n)
)
X_circle = circle_factory()
X_circle_noise = circle_noise_factory()
X_circle_outliers = circle_outliers_factory()

# Circle Gauss
circle_gauss_factory = partial(arc, n=n, sampling="normal")
circle_gauss_noise_factory = compose(partial(add_noise, sd=sd), circle_gauss_factory)
circle_gauss_outliers_factory = compose(
    partial(add_outliers, frac=outliers_frac, iqr_factor=iqr_factor),
    circle_gauss_factory
)
X_circle_gauss = circle_gauss_factory()
X_circle_gauss_noise = circle_gauss_noise_factory()
X_circle_gauss_outliers = circle_gauss_outliers_factory()

# Eyeglasses
eyeglasses_factory = partial(eyeglasses, n=n_eyeglasses, bridge_height=bridge_height)
eyeglasses_noise_factory = compose(partial(add_noise, sd=sd_eyeglasses), eyeglasses_factory)
eyeglasses_outliers_factory = compose(
    partial(add_outliers, frac=outliers_frac, iqr_factor=iqr_factor),
    eyeglasses_factory
)
X_eyeglasses = eyeglasses_factory()
X_eyeglasses_noise = eyeglasses_noise_factory()
X_eyeglasses_outliers = eyeglasses_outliers_factory()

# Filled
filled_circle_factory = partial(filled_circle, n=n_filled, r_power=r_power, max_r=max_r)
X_filled = filled_circle_factory()

```

## Conjuntos de Datos Sintéticos

### Diagramas de persistencia e intervalos {#sec-results-diagrams-plus-intervals}


A continuación se presentan, individualmente para cada uno de los conjuntos de datos, los diagramas de persistencia e intervalos de confianza computados sobre los mismos para cada uno de los métodos

#### Círculo uniforme

```{python}
#| label: fig-sim-intervals-circle-base
#| fig-cap: Conjunto de datos e intervalos de confianza obtenidos para la circunferencia uniforme
intervals = run_all_intervals(
    X_circle, h=h, robust_quantile=robust_quantile, log=False, plot=True, B=B_intervals
)
```

```{python}
#| label: fig-sim-intervals-circle-noise
#| fig-cap: Conjunto de datos e intervalos de confianza obtenidos para la circunferencia uniforme con ruido agregado.
intervals = run_all_intervals(
    X_circle_noise, h=h, robust_quantile=robust_quantile, log=False, plot=True, B=B_intervals
)
```



### Potencia {#sec-results-power}

Si ahora se repite en procedimiento realizado en la @sec-results-diagrams-plus-intervals un cantidad $M$ de veces con el objetivo de analizar la frecuencia en la que el intervalo estimado contiene efectivamente a la cantidad de agujeros reales, siendo en nuestro caso un agujero real para todos los conjuntos de datos analizados, entonces se obtiene la potencia del test, es decir, la probabilidad de rechazar la hipótesis nula dado que esta es falsa, donde la hipótesis nula representa la no existencia de agujeros en la topología


## Conjuntos de Datos Reales
